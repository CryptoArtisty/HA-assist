<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Enhanced Heikin Ashi Crypto Trader - Fixed</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/lightweight-charts@4.0.0/dist/lightweight-charts.standalone.production.js"></script>
  <style>
    * {
      font-family: 'Inter', sans-serif;
    }
    
    :root {
      --primary-bg: #0f172a;
      --secondary-bg: #1e293b;
      --accent-bg: #334155;
      --text-primary: #f8fafc;
      --text-secondary: #cbd5e1;
      --border-color: #475569;
      --success-color: #10b981;
      --danger-color: #ef4444;
      --warning-color: #f59e0b;
      --info-color: #3b82f6;
    }
    
    [data-theme="light"] {
      --primary-bg: #ffffff;
      --secondary-bg: #f8fafc;
      --accent-bg: #e2e8f0;
      --text-primary: #1e293b;
      --text-secondary: #475569;
      --border-color: #cbd5e1;
      --success-color: #059669;
      --danger-color: #dc2626;
      --warning-color: #d97706;
      --info-color: #2563eb;
    }
    
    body {
      background-color: var(--primary-bg);
      color: var(--text-primary);
      transition: all 0.3s ease;
    }
    
    .bg-primary { background-color: var(--primary-bg); }
    .bg-secondary { background-color: var(--secondary-bg); }
    .bg-accent { background-color: var(--accent-bg); }
    .text-primary { color: var(--text-primary); }
    .text-secondary { color: var(--text-secondary); }
    .border-custom { border-color: var(--border-color); }
    
    .chart-wrapper {
      background-color: var(--secondary-bg);
      border: 1px solid var(--border-color);
      transition: all 0.3s ease;
    }
    
    .chart-wrapper:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 25px rgba(0,0,0,0.1);
    }
    
    .control-panel {
      background: linear-gradient(135deg, var(--secondary-bg) 0%, var(--accent-bg) 100%);
      border: 1px solid var(--border-color);
      backdrop-filter: blur(10px);
    }
    
    .theme-toggle {
      position: relative;
      display: inline-block;
      width: 60px;
      height: 30px;
    }
    
    .theme-toggle input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: var(--border-color);
      transition: .3s;
      border-radius: 30px;
    }
    
    .slider:before {
      position: absolute;
      content: "";
      height: 22px;
      width: 22px;
      left: 4px;
      bottom: 4px;
      background-color: var(--primary-bg);
      transition: .3s;
      border-radius: 50%;
    }
    
    input:checked + .slider {
      background-color: var(--info-color);
    }
    
    input:checked + .slider:before {
      transform: translateX(30px);
    }
    
    .alert-toggle {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 26px;
    }
    
    .alert-toggle input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .alert-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: var(--border-color);
      transition: .3s;
      border-radius: 26px;
    }
    
    .alert-slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 4px;
      bottom: 4px;
      background-color: var(--primary-bg);
      transition: .3s;
      border-radius: 50%;
    }
    
    input:checked + .alert-slider {
      background-color: var(--success-color);
    }
    
    input:checked + .alert-slider:before {
      transform: translateX(24px);
    }
    
    .loading-spinner {
      border: 3px solid var(--border-color);
      border-top: 3px solid var(--info-color);
      border-radius: 50%;
      width: 30px;
      height: 30px;
      animation: spin 1s linear infinite;
      margin: 0 auto;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .error-message {
      background-color: rgba(239, 68, 68, 0.1);
      border: 1px solid var(--danger-color);
      color: var(--danger-color);
      padding: 12px;
      border-radius: 8px;
      margin: 10px 0;
    }
    
    .success-message {
      background-color: rgba(16, 185, 129, 0.1);
      border: 1px solid var(--success-color);
      color: var(--success-color);
      padding: 12px;
      border-radius: 8px;
      margin: 10px 0;
    }
    
    .tooltip {
      position: absolute;
      pointer-events: none;
      background-color: var(--secondary-bg);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
      font-size: 12px;
      padding: 8px 12px;
      border-radius: 6px;
      display: none;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    
    .pattern-badge {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 500;
      margin: 2px;
    }
    
    .pattern-doji { background-color: rgba(255, 255, 0, 0.2); color: #fbbf24; }
    .pattern-wickless { background-color: rgba(255, 153, 0, 0.2); color: #f97316; }
    .pattern-reversal { background-color: rgba(255, 0, 255, 0.2); color: #ec4899; }
    .pattern-support { background-color: rgba(59, 130, 246, 0.2); color: #3b82f6; }
    .pattern-resistance { background-color: rgba(239, 68, 68, 0.2); color: #ef4444; }
    
    .status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      display: inline-block;
      margin-right: 8px;
    }
    
    .status-online { background-color: var(--success-color); }
    .status-offline { background-color: var(--danger-color); }
    .status-loading { background-color: var(--warning-color); animation: pulse 2s infinite; }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    .btn-primary {
      background: linear-gradient(135deg, var(--info-color) 0%, #1d4ed8 100%);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: 500;
    }
    
    .btn-primary:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    }
    
    .btn-secondary {
      background-color: var(--accent-bg);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: 500;
    }
    
    .btn-secondary:hover {
      background-color: var(--secondary-bg);
      transform: translateY(-1px);
    }
    
    .btn-secondary.active {
      background-color: var(--info-color);
      color: white;
      border-color: var(--info-color);
    }
    
    select, input[type="range"] {
      background-color: var(--accent-bg);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 8px 12px;
      transition: all 0.2s ease;
    }
    
    select:focus, input:focus {
      outline: none;
      border-color: var(--info-color);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }
    
    .alert-item {
      background-color: var(--accent-bg);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 12px;
      margin: 8px 0;
      transition: all 0.2s ease;
    }
    
    .alert-item:hover {
      transform: translateX(4px);
      border-color: var(--info-color);
    }
    
    .alert-item.buy {
      border-left: 4px solid var(--success-color);
    }
    
    .alert-item.sell {
      border-left: 4px solid var(--danger-color);
    }
    
    @media (max-width: 768px) {
      .chart-wrapper {
        width: 100% !important;
        min-width: unset !important;
        height: 250px !important;
      }
      
      .control-panel {
        flex-direction: column;
        gap: 16px;
      }
      
      .control-group {
        width: 100%;
      }
    }
    
    @media print {
      body { print-color-adjust: exact; }
      .no-print { display: none !important; }
    }
    
    /* Scrollbar styling */
    ::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }
    
    ::-webkit-scrollbar-track {
      background: var(--accent-bg);
      border-radius: 3px;
    }
    
    ::-webkit-scrollbar-thumb {
      background: var(--border-color);
      border-radius: 3px;
    }
    
    ::-webkit-scrollbar-thumb:hover {
      background: var(--text-secondary);
    }
  </style>
</head>
<body data-theme="dark" class="bg-primary text-primary">
  <div class="container mx-auto px-4 py-6">
    <!-- Header -->
    <div class="text-center mb-8">
      <h1 class="text-4xl font-bold bg-gradient-to-r from-blue-400 to-purple-500 bg-clip-text text-transparent mb-2">
        <i class="fas fa-chart-line mr-3"></i>
        Enhanced Heikin Ashi Crypto Trader
      </h1>
      <p class="text-secondary text-lg">Advanced cryptocurrency trading with Heikin Ashi pattern recognition</p>
    </div>
    
    <!-- Theme Toggle -->
    <div class="fixed top-4 right-4 z-50 no-print">
      <div class="flex items-center gap-3 bg-secondary p-3 rounded-lg shadow-lg border border-custom">
        <i class="fas fa-sun text-yellow-400"></i>
        <label class="theme-toggle">
          <input type="checkbox" id="theme-toggle">
          <span class="slider"></span>
        </label>
        <i class="fas fa-moon text-blue-400"></i>
      </div>
    </div>
    
    <!-- Status Bar -->
    <div id="status-bar" class="mb-6 p-4 bg-secondary border border-custom rounded-lg">
      <div class="flex flex-wrap items-center justify-between">
        <div class="flex items-center gap-4">
          <div class="flex items-center">
            <span class="status-indicator status-loading" id="connection-status"></span>
            <span class="text-sm font-medium" id="status-text">Connecting...</span>
          </div>
          <div class="text-sm text-secondary" id="last-update">
            Last updated: <span id="update-time">Never</span>
          </div>
        </div>
        <div class="text-sm text-secondary" id="refresh-status">
          Next update: <span id="next-refresh">-</span>
        </div>
      </div>
    </div>
    
    <!-- Error Display -->
    <div id="error-container" style="display: none;"></div>
    
    <!-- Control Panel -->
    <div id="controls" class="control-panel p-6 rounded-xl mb-8 shadow-lg">
      <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
        <!-- Cryptocurrency Selection -->
        <div class="control-group">
          <label class="block text-sm font-semibold mb-2">
            <i class="fab fa-bitcoin mr-2"></i>Cryptocurrency
          </label>
          <select id="crypto-select" class="w-full">
            <option value="BTCUSDT">Bitcoin (BTC/USDT)</option>
            <option value="ETHUSDT">Ethereum (ETH/USDT)</option>
            <option value="SOLUSDT">Solana (SOL/USDT)</option>
            <option value="ADAUSDT">Cardano (ADA/USDT)</option>
            <option value="BNBUSDT">Binance Coin (BNB/USDT)</option>
            <option value="UNIUSDT">Uniswap (UNI/USDT)</option>
            <option value="XRPUSDT">XRP (XRP/USDT)</option>
          </select>
        </div>
        
        <!-- Pattern Selection -->
        <div class="control-group">
          <label class="block text-sm font-semibold mb-2">
            <i class="fas fa-pattern mr-2"></i>Heikin Ashi Patterns
          </label>
          <select id="pattern-select" multiple size="5" class="w-full">
            <option value="doji" selected>Doji Candles</option>
            <option value="wickless" selected>First Wickless</option>
            <option value="reversal" selected>Trend Reversals</option>
            <option value="zones" selected>Support/Resistance</option>
            <option value="trend" selected>Trend Strength</option>
          </select>
        </div>
        
        <!-- Alert Settings -->
        <div class="control-group">
          <label class="block text-sm font-semibold mb-4">
            <i class="fas fa-bell mr-2"></i>Alert Settings
          </label>
          <div class="space-y-3">
            <div class="flex items-center justify-between">
              <span class="text-sm">Enable Alerts</span>
              <label class="alert-toggle">
                <input type="checkbox" id="enable-alerts">
                <span class="alert-slider"></span>
              </label>
            </div>
            <div>
              <label class="block text-xs text-secondary mb-1">Volume Filter</label>
              <div class="flex items-center gap-2">
                <input type="range" min="0" max="5000" step="50" id="volume-filter" value="0" class="flex-1">
                <span id="volume-value" class="text-sm font-mono w-12 text-right">0</span>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Statistics -->
        <div class="control-group">
          <label class="block text-sm font-semibold mb-2">
            <i class="fas fa-chart-bar mr-2"></i>Statistics
          </label>
          <div class="space-y-2 text-sm">
            <div class="flex justify-between">
              <span>Total Alerts:</span>
              <span id="total-alerts" class="font-mono">0</span>
            </div>
            <div class="flex justify-between">
              <span>Buy Signals:</span>
              <span id="buy-signals" class="font-mono text-green-400">0</span>
            </div>
            <div class="flex justify-between">
              <span>Sell Signals:</span>
              <span id="sell-signals" class="font-mono text-red-400">0</span>
            </div>
            <div class="flex justify-between">
              <span>Success Rate:</span>
              <span id="success-rate" class="font-mono">0%</span>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Timeframe Selector -->
    <div class="timeframe-selector text-center mb-8">
      <h3 class="text-lg font-semibold mb-4">
        <i class="fas fa-clock mr-2"></i>Select Timeframe
      </h3>
      <div class="flex flex-wrap justify-center gap-2">
        <button class="btn-secondary timeframe-btn active" data-tf="1m">1m</button>
        <button class="btn-secondary timeframe-btn" data-tf="5m">5m</button>
        <button class="btn-secondary timeframe-btn" data-tf="15m">15m</button>
        <button class="btn-secondary timeframe-btn" data-tf="1h">1h</button>
        <button class="btn-secondary timeframe-btn" data-tf="4h">4h</button>
        <button class="btn-secondary timeframe-btn" data-tf="1d">1d</button>
        <button class="btn-secondary timeframe-btn" data-tf="1w">1w</button>
      </div>
    </div>
    
    <!-- Loading Indicator -->
    <div id="loading-indicator" class="text-center mb-6" style="display: none;">
      <div class="loading-spinner mb-2"></div>
      <p class="text-secondary">Loading chart data...</p>
    </div>
    
    <!-- Chart Container -->
    <div id="chart-container" class="mb-8"></div>
    
    <!-- Tooltip -->
    <div class="tooltip" id="tooltip"></div>
    
    <!-- Alert History -->
    <div id="alert-history" class="bg-secondary border border-custom rounded-xl p-6 shadow-lg mb-8">
      <div class="flex items-center justify-between mb-4">
        <h3 class="text-xl font-semibold flex items-center">
          <i class="fas fa-history mr-2"></i>Alert History
        </h3>
        <button id="clear-alerts" class="btn-primary">
          <i class="fas fa-trash mr-2"></i>Clear Alerts
        </button>
      </div>
      <div id="alert-list" class="space-y-2">
        <p class="text-secondary text-center py-4">No alerts yet. Enable alerts to start receiving notifications.</p>
      </div>
    </div>
    
    <!-- Pattern Descriptions -->
    <div id="descriptions" class="bg-secondary border border-custom rounded-xl p-6 shadow-lg">
      <h3 class="text-2xl font-bold mb-6 flex items-center">
        <i class="fas fa-book mr-3"></i>Heikin Ashi Pattern Guide
      </h3>
      
      <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
        <div>
          <h4 class="text-lg font-semibold mb-4">Pattern Types</h4>
          <div class="space-y-4">
            <div class="flex items-start gap-3">
              <span class="pattern-badge pattern-doji">DOJI</span>
              <div class="text-sm">
                <p class="font-medium mb-1">Doji Candles</p>
                <p class="text-secondary">Small body with wicks indicating indecision. Potential reversal signals at trend extremes.</p>
              </div>
            </div>
            
            <div class="flex items-start gap-3">
              <span class="pattern-badge pattern-wickless">WICKLESS</span>
              <div class="text-sm">
                <p class="font-medium mb-1">First Wickless Candles</p>
                <p class="text-secondary">Strong directional moves without retracements. Indicates powerful momentum shifts.</p>
              </div>
            </div>
            
            <div class="flex items-start gap-3">
              <span class="pattern-badge pattern-reversal">REVERSAL</span>
              <div class="text-sm">
                <p class="font-medium mb-1">Trend Reversals</p>
                <p class="text-secondary">Color changes after strong trends, often coinciding with support/resistance levels.</p>
              </div>
            </div>
            
            <div class="flex items-start gap-3">
              <span class="pattern-badge pattern-support">ZONES</span>
              <div class="text-sm">
                <p class="font-medium mb-1">Support/Resistance</p>
                <p class="text-secondary">Key price levels where reversals frequently occur. More reliable on Heikin Ashi charts.</p>
              </div>
            </div>
          </div>
        </div>
        
        <div>
          <h4 class="text-lg font-semibold mb-4">Trading Rules</h4>
          <ol class="space-y-3 text-sm">
            <li class="flex items-start gap-3">
              <span class="bg-info-color text-white rounded-full w-6 h-6 flex items-center justify-center text-xs font-bold">1</span>
              <p>Trade in direction of Heikin Ashi color (green = long, red = short)</p>
            </li>
            <li class="flex items-start gap-3">
              <span class="bg-info-color text-white rounded-full w-6 h-6 flex items-center justify-center text-xs font-bold">2</span>
              <p>Enter on first wickless candle in direction of trend</p>
            </li>
            <li class="flex items-start gap-3">
              <span class="bg-info-color text-white rounded-full w-6 h-6 flex items-center justify-center text-xs font-bold">3</span>
              <p>Exit when opposite color appears or doji forms after strong move</p>
            </li>
            <li class="flex items-start gap-3">
              <span class="bg-info-color text-white rounded-full w-6 h-6 flex items-center justify-center text-xs font-bold">4</span>
              <p>Use higher timeframes to determine primary trend direction</p>
            </li>
            <li class="flex items-start gap-3">
              <span class="bg-info-color text-white rounded-full w-6 h-6 flex items-center justify-center text-xs font-bold">5</span>
              <p>Support/resistance levels are more significant on Heikin Ashi charts</p>
            </li>
          </ol>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Global variables
    const chartContainer = document.getElementById('chart-container');
    const tooltipEl = document.getElementById('tooltip');
    const volumeFilterInput = document.getElementById('volume-filter');
    const volumeDisplay = document.getElementById('volume-value');
    const cryptoSelect = document.getElementById('crypto-select');
    const patternSelect = document.getElementById('pattern-select');
    const alertList = document.getElementById('alert-list');
    const clearAlertsBtn = document.getElementById('clear-alerts');
    const nextRefreshEl = document.getElementById('next-refresh');
    const statusBar = document.getElementById('status-bar');
    const connectionStatus = document.getElementById('connection-status');
    const statusText = document.getElementById('status-text');
    const updateTime = document.getElementById('update-time');
    const loadingIndicator = document.getElementById('loading-indicator');
    const errorContainer = document.getElementById('error-container');
    const themeToggle = document.getElementById('theme-toggle');
    const enableAlertsToggle = document.getElementById('enable-alerts');
    
    // Statistics elements
    const totalAlertsEl = document.getElementById('total-alerts');
    const buySignalsEl = document.getElementById('buy-signals');
    const sellSignalsEl = document.getElementById('sell-signals');
    const successRateEl = document.getElementById('success-rate');
    
    // Initialize
    volumeDisplay.textContent = volumeFilterInput.value;
    let isOnline = true;
    let retryCount = 0;
    const maxRetries = 3;
    
    // Storage constants
    const CHART_DATA_STORAGE_KEY = 'heikinAshiChartData';
    const MAX_CHART_DATA_ITEMS = 100;
    const ALERT_STORAGE_KEY = 'heikinAshiAlerts';
    const MAX_ALERTS = 100;
    
    // Alert rate limiting
    let lastAlertTime = 0;
    const ALERT_COOLDOWN = 30000; // 30 seconds
    
    // Theme Management
    function initializeTheme() {
      const savedTheme = localStorage.getItem('heikin-theme') || 'dark';
      document.body.setAttribute('data-theme', savedTheme);
      themeToggle.checked = savedTheme === 'light';
    }
    
    themeToggle.addEventListener('change', (e) => {
      const theme = e.target.checked ? 'light' : 'dark';
      document.body.setAttribute('data-theme', theme);
      localStorage.setItem('heikin-theme', theme);
      
      // Update all charts with new theme
      Object.values(activeCharts).forEach(chartData => {
        if (chartData.chart) {
          const isDark = theme === 'dark';
          chartData.chart.applyOptions({
            layout: {
              background: { color: isDark ? '#1e293b' : '#ffffff' },
              textColor: isDark ? '#cbd5e1' : '#475569'
            },
            grid: {
              vertLines: { color: isDark ? '#334155' : '#e2e8f0' },
              horzLines: { color: isDark ? '#334155' : '#e2e8f0' }
            }
          });
        }
      });
    });
    
    // Error Handling
    function showError(message, details = '') {
      const errorDiv = document.createElement('div');
      errorDiv.className = 'error-message';
      errorDiv.innerHTML = `
        <div class="flex items-center justify-between">
          <div class="flex items-center gap-3">
            <i class="fas fa-exclamation-triangle"></i>
            <div>
              <p class="font-medium">${message}</p>
              ${details ? `<p class="text-sm mt-1">${details}</p>` : ''}
            </div>
          </div>
          <button onclick="this.parentElement.parentElement.remove()" class="text-red-400 hover:text-red-300">
            <i class="fas fa-times"></i>
          </button>
        </div>
      `;
      errorContainer.appendChild(errorDiv);
      errorContainer.style.display = 'block';
      
      // Auto-remove after 10 seconds
      setTimeout(() => {
        if (errorDiv.parentElement) {
          errorDiv.remove();
        }
        if (errorContainer.children.length === 0) {
          errorContainer.style.display = 'none';
        }
      }, 10000);
    }
    
    function showSuccess(message) {
      const successDiv = document.createElement('div');
      successDiv.className = 'success-message';
      successDiv.innerHTML = `
        <div class="flex items-center justify-between">
          <div class="flex items-center gap-3">
            <i class="fas fa-check-circle"></i>
            <p class="font-medium">${message}</p>
          </div>
          <button onclick="this.parentElement.parentElement.remove()" class="text-green-400 hover:text-green-300">
            <i class="fas fa-times"></i>
          </button>
        </div>
      `;
      errorContainer.appendChild(successDiv);
      errorContainer.style.display = 'block';
      
      // Auto-remove after 5 seconds
      setTimeout(() => {
        if (successDiv.parentElement) {
          successDiv.remove();
        }
        if (errorContainer.children.length === 0) {
          errorContainer.style.display = 'none';
        }
      }, 5000);
    }
    
    function updateConnectionStatus(online, message = '') {
      isOnline = online;
      connectionStatus.className = `status-indicator ${online ? 'status-online' : 'status-offline'}`;
      statusText.textContent = online ? 'Connected' : (message || 'Disconnected');
      
      if (online) {
        retryCount = 0;
      }
    }
    
    // Chart Data Storage Management
    function storeChartData(symbol, timeframe, data) {
      try {
        const storedData = JSON.parse(localStorage.getItem(CHART_DATA_STORAGE_KEY)) || {};
        const key = `${symbol}_${timeframe}`;
        
        // Initialize if not exists
        if (!storedData[key]) {
          storedData[key] = [];
        }
        
        // Add new data
        storedData[key].push({
          timestamp: Date.now(),
          data: data
        });
        
        // Keep only the most recent data
        if (storedData[key].length > MAX_CHART_DATA_ITEMS) {
          storedData[key].shift(); // Remove oldest entry
        }
        
        localStorage.setItem(CHART_DATA_STORAGE_KEY, JSON.stringify(storedData));
      } catch (e) {
        console.error('Failed to store chart data:', e);
      }
    }
    
    function getCachedChartData(symbol, timeframe) {
      try {
        const storedData = JSON.parse(localStorage.getItem(CHART_DATA_STORAGE_KEY)) || {};
        const key = `${symbol}_${timeframe}`;
        
        if (storedData[key] && storedData[key].length > 0) {
          // Return the most recent cached data
          return storedData[key][storedData[key].length - 1].data;
        }
      } catch (e) {
        console.error('Failed to retrieve cached chart data:', e);
      }
      return null;
    }
    
    // Alert System
    let alerts = JSON.parse(localStorage.getItem(ALERT_STORAGE_KEY)) || [];
    let alertStats = { total: 0, buy: 0, sell: 0, successful: 0 };
    
    function updateAlertStats() {
      alertStats.total = alerts.length;
      alertStats.buy = alerts.filter(a => a.type === 'buy').length;
      alertStats.sell = alerts.filter(a => a.type === 'sell').length;
      
      totalAlertsEl.textContent = alertStats.total;
      buySignalsEl.textContent = alertStats.buy;
      sellSignalsEl.textContent = alertStats.sell;
      
      // Calculate success rate (placeholder logic - would need actual trade results)
      const successRate = alertStats.total > 0 ? ((alertStats.successful / alertStats.total) * 100).toFixed(1) : 0;
      successRateEl.textContent = `${successRate}%`;
    }
    
    function renderAlerts() {
      if (alerts.length === 0) {
        alertList.innerHTML = '<p class="text-secondary text-center py-4">No alerts yet. Enable alerts to start receiving notifications.</p>';
      } else {
        alertList.innerHTML = '';
        alerts.slice().reverse().slice(0, 20).forEach(alert => {
          const alertEl = document.createElement('div');
          alertEl.className = `alert-item ${alert.type}`;
          alertEl.innerHTML = `
            <div class="flex items-start justify-between">
              <div class="flex items-center gap-3">
                <i class="fas ${alert.type === 'buy' ? 'fa-arrow-up text-green-400' : 'fa-arrow-down text-red-400'}"></i>
                <div>
                  <p class="font-medium">${alert.message}</p>
                  <p class="text-xs text-secondary mt-1">${new Date(alert.time).toLocaleString()}</p>
                </div>
              </div>
              <span class="pattern-badge ${alert.pattern || 'pattern-reversal'}">${alert.symbol}</span>
            </div>
          `;
          alertList.appendChild(alertEl);
        });
      }
      updateAlertStats();
    }
    
    function addAlert(type, message, pattern = '') {
      if (!enableAlertsToggle.checked) return;
      
      // Check for duplicate alerts (same type, same message, within last 5 minutes)
      const now = Date.now();
      const isDuplicate = alerts.some(alert => 
        alert.type === type && 
        alert.message === message && 
        (now - alert.time) < 300000 // 5 minutes
      );
      
      if (isDuplicate) return;
      
      // Check if we're in cooldown period
      if (now - lastAlertTime < ALERT_COOLDOWN) {
        console.log('Alert suppressed due to rate limiting');
        return;
      }
      
      lastAlertTime = now;
      
      const timestamp = Date.now();
      const alertObj = {
        type,
        message,
        time: timestamp,
        symbol: currentSymbol,
        pattern: pattern
      };
      
      alerts.push(alertObj);
      if (alerts.length > MAX_ALERTS) {
        alerts.shift();
      }
      
      try {
        localStorage.setItem(ALERT_STORAGE_KEY, JSON.stringify(alerts));
      } catch (e) {
        showError('Failed to save alert to storage', 'Local storage may be full');
      }
      
      renderAlerts();
      playAlert(type, message);
    }
    
    function playAlert(type, message) {
      if (!enableAlertsToggle.checked) return;
      
      // Create beep sound with error handling
      try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const beep = () => {
          const oscillator = ctx.createOscillator();
          const gainNode = ctx.createGain();
          
          oscillator.type = 'sine';
          oscillator.frequency.value = type === 'buy' ? 880 : 440;
          gainNode.gain.value = 0.3;
          
          oscillator.connect(gainNode);
          gainNode.connect(ctx.destination);
          
          oscillator.start();
          gainNode.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.5);
          oscillator.stop(ctx.currentTime + 0.5);
        };
        
        // Play beep 2 times
        beep();
        setTimeout(beep, 300);
        
        // Show browser notification if supported
        if ('Notification' in window && Notification.permission === 'granted') {
          new Notification(`Heikin Ashi Alert - ${type.toUpperCase()}`, {
            body: message,
            icon: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIGZpbGw9Im5vbmUiIHN0cm9rZT0iY3VycmVudENvbG9yIiB2aWV3Qm94PSIwIDAgMjQgMjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjIiIGQ9Ik05IDEyaDZ2MTBIM3oiLz48L3N2Zz4='
          });
        }
      } catch (e) {
        console.warn('Audio context not available:', e);
      }
    }
    
    // Request notification permission
    if ('Notification' in window && Notification.permission === 'default') {
      Notification.requestPermission();
    }
    
    clearAlertsBtn.addEventListener('click', () => {
      if (confirm('Are you sure you want to clear all alerts?')) {
        alerts = [];
        localStorage.setItem(ALERT_STORAGE_KEY, JSON.stringify(alerts));
        renderAlerts();
        showSuccess('All alerts cleared successfully');
      }
    });
    
    // Auto-refresh system
    let refreshInterval = null;
    let lastRefreshTime = Date.now();
    const timeframeRefreshRates = {
      '1m': 15000,    // 15 seconds
      '5m': 30000,    // 30 seconds  
      '15m': 60000,   // 1 minute
      '1h': 300000,   // 5 minutes
      '4h': 900000,   // 15 minutes
      '1d': 3600000,  // 1 hour
      '1w': 86400000  // 24 hours
    };
    
    function updateRefreshTimer() {
      const refreshRate = timeframeRefreshRates[currentTimeframe] || 60000;
      const nextRefresh = lastRefreshTime + refreshRate;
      const timeLeft = Math.max(0, nextRefresh - Date.now());
      
      const secondsLeft = Math.ceil(timeLeft / 1000);
      nextRefreshEl.textContent = `${secondsLeft}s`;
      
      if (timeLeft <= 0 && isOnline) {
        refreshCharts();
      }
    }
    
    function startRefreshTimer() {
      if (refreshInterval) clearInterval(refreshInterval);
      updateRefreshTimer();
      refreshInterval = setInterval(updateRefreshTimer, 1000);
    }
    
    function refreshCharts() {
      lastRefreshTime = Date.now();
      loadCharts(currentTimeframe);
    }
    
    // Volume filter
    volumeFilterInput.addEventListener('input', () => {
      volumeDisplay.textContent = volumeFilterInput.value;
      updateMarkers();
    });
    
    // Chart management
    let activeCharts = {};
    let currentTimeframe = '1m';
    let currentSymbol = 'BTCUSDT';
    
    const timeframeButtons = document.querySelectorAll('.timeframe-btn');
    timeframeButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        if (btn.classList.contains('active')) return;
        
        timeframeButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentTimeframe = btn.dataset.tf;
        loadCharts(currentTimeframe);
        startRefreshTimer();
      });
    });
    
    cryptoSelect.addEventListener('change', () => {
      const oldSymbol = currentSymbol;
      currentSymbol = cryptoSelect.value;
      
      if (oldSymbol !== currentSymbol) {
        showSuccess(`Switched to ${currentSymbol}`);
        loadCharts(currentTimeframe);
      }
    });
    
    // Heikin Ashi conversion
    function convertToHeikinAshi(candles) {
      if (candles.length === 0) return [];
      
      try {
        const haCandles = [];
        const first = candles[0];
        
        // First HA candle
        haCandles.push({
          time: first.time,
          open: (first.open + first.close) / 2,
          high: first.high,
          low: first.low,
          close: (first.open + first.close + first.high + first.low) / 4,
          volume: first.volume
        });
        
        // Subsequent candles
        for (let i = 1; i < candles.length; i++) {
          const curr = candles[i];
          const prevHA = haCandles[i-1];
          
          const haOpen = (prevHA.open + prevHA.close) / 2;
          const haClose = (curr.open + curr.close + curr.high + curr.low) / 4;
          const haHigh = Math.max(curr.high, haOpen, haClose);
          const haLow = Math.min(curr.low, haOpen, haClose);
          
          haCandles.push({
            time: curr.time,
            open: haOpen,
            high: haHigh,
            low: haLow,
            close: haClose,
            volume: curr.volume
          });
        }
        
        return haCandles;
      } catch (error) {
        showError('Failed to convert to Heikin Ashi', error.message);
        return [];
      }
    }
    
    // Chart creation
    function createChartElement(timeframe) {
      const wrapper = document.createElement('div');
      wrapper.className = 'chart-wrapper rounded-xl overflow-hidden shadow-lg w-full';
      wrapper.style.height = '400px';
      wrapper.id = `chart-${timeframe}`;
      
      const title = document.createElement('div');
      title.className = 'absolute top-4 left-4 z-10 bg-secondary bg-opacity-90 px-3 py-2 rounded-lg text-sm font-semibold border border-custom';
      title.innerHTML = `
        <i class="fab fa-bitcoin mr-2"></i>
        ${currentSymbol} ${timeframe} Heikin Ashi
      `;
      
      const chartEl = document.createElement('div');
      chartEl.className = 'chart relative';
      chartEl.style.width = '100%';
      chartEl.style.height = '100%';
      
      wrapper.appendChild(title);
      wrapper.appendChild(chartEl);
      chartContainer.appendChild(wrapper);
      
      const isDark = document.body.getAttribute('data-theme') === 'dark';
      const chart = LightweightCharts.createChart(chartEl, {
        layout: {
          background: { color: isDark ? '#1e293b' : '#ffffff' },
          textColor: isDark ? '#cbd5e1' : '#475569'
        },
        grid: {
          vertLines: { color: isDark ? '#334155' : '#e2e8f0' },
          horzLines: { color: isDark ? '#334155' : '#e2e8f0' }
        },
        timeScale: { 
          timeVisible: true,
          secondsVisible: timeframe === '1m'
        },
        crosshair: { mode: 1 },
        rightPriceScale: {
          borderColor: isDark ? '#334155' : '#e2e8f0'
        },
        timeScale: {
          borderColor: isDark ? '#334155' : '#e2e8f0'
        }
      });
      
      const candleSeries = chart.addCandlestickSeries({
        upColor: '#10b981',
        downColor: '#ef4444',
        borderUpColor: '#10b981',
        borderDownColor: '#ef4444',
        wickUpColor: '#10b981',
        wickDownColor: '#ef4444'
      });
      
      // Auto-resize chart
      const resizeObserver = new ResizeObserver(() => {
        chart.applyOptions({ width: chartEl.clientWidth });
      });
      resizeObserver.observe(chartEl);
      
      return { chart, candleSeries, wrapper, resizeObserver, priceLines: [] };
    }
    
    // Fixed Support/Resistance zones implementation
    function drawZones(candles, chartData) {
      if (!chartData || !chartData.chart) return;
      
      try {
        // Clear existing price lines first
        if (chartData.priceLines && chartData.priceLines.length > 0) {
          chartData.priceLines.forEach(priceLine => {
            try {
              chartData.candleSeries.removePriceLine(priceLine);
            } catch (e) {
              console.warn('Failed to remove price line:', e);
            }
          });
          chartData.priceLines = [];
        }
        
        const levels = [];
        const minCandleDistance = 5; // Minimum candles between levels
        
        // Enhanced support/resistance detection
        for (let i = 3; i < candles.length - 3; i++) {
          const curr = candles[i];
          const prev3 = candles[i - 3];
          const prev2 = candles[i - 2];
          const prev1 = candles[i - 1];
          const next1 = candles[i + 1];
          const next2 = candles[i + 2];
          const next3 = candles[i + 3];
          
          // Support level detection (local low)
          if (curr.low <= prev3.low && curr.low <= prev2.low && 
              curr.low <= prev1.low && curr.low <= next1.low && 
              curr.low <= next2.low && curr.low <= next3.low) {
            
            // Check if this level is not too close to existing levels
            const tooClose = levels.some(level => 
              Math.abs(level.price - curr.low) < curr.low * 0.002 // 0.2% tolerance
            );
            
            if (!tooClose) {
              levels.push({ 
                price: curr.low, 
                type: 'support', 
                strength: calculateLevelStrength(candles, i, curr.low, 'support'),
                time: curr.time
              });
            }
          }
          
          // Resistance level detection (local high)
          if (curr.high >= prev3.high && curr.high >= prev2.high && 
              curr.high >= prev1.high && curr.high >= next1.high && 
              curr.high >= next2.high && curr.high >= next3.high) {
            
            // Check if this level is not too close to existing levels
            const tooClose = levels.some(level => 
              Math.abs(level.price - curr.high) < curr.high * 0.002 // 0.2% tolerance
            );
            
            if (!tooClose) {
              levels.push({ 
                price: curr.high, 
                type: 'resistance', 
                strength: calculateLevelStrength(candles, i, curr.high, 'resistance'),
                time: curr.time
              });
            }
          }
        }
        
        // Sort by strength and take the top levels
        levels.sort((a, b) => b.strength - a.strength);
        const topLevels = levels.slice(0, 8);
        
        // Draw price lines for the strongest levels
        topLevels.forEach(level => {
          try {
            const priceLine = chartData.candleSeries.createPriceLine({
              price: level.price,
              color: level.type === 'support' ? 
                'rgba(16, 185, 129, 0.7)' : 'rgba(239, 68, 68, 0.7)',
              lineWidth: 2,
              lineStyle: 1,
              axisLabelVisible: true,
              title: `${level.type.charAt(0).toUpperCase() + level.type.slice(1)} (${level.strength.toFixed(1)})`
            });
            
            if (priceLine) {
              chartData.priceLines.push(priceLine);
            }
          } catch (e) {
            console.warn('Failed to create price line:', e);
          }
        });
        
      } catch (error) {
        console.error('Failed to draw zones:', error);
      }
    }
    
    // Calculate the strength of a support/resistance level
    function calculateLevelStrength(candles, index, price, type) {
      let strength = 1;
      const tolerance = price * 0.003; // 0.3% tolerance
      
      // Check how many times price touched this level
      for (let i = 0; i < candles.length; i++) {
        if (i === index) continue;
        
        const candle = candles[i];
        
        if (type === 'support') {
          if (Math.abs(candle.low - price) <= tolerance) {
            strength += 1;
          }
        } else { // resistance
          if (Math.abs(candle.high - price) <= tolerance) {
            strength += 1;
          }
        }
      }
      
      // Bonus for recent levels
      const timeDiff = Date.now() - (candles[index].time * 1000);
      const daysDiff = timeDiff / (1000 * 60 * 60 * 24);
      if (daysDiff < 7) {
        strength += 0.5;
      }
      
      return strength;
    }
    
    // Pattern detection
    function detectHeikinAshiPatterns(haCandles, timeframe) {
      const dojiMarkers = [];
      const wicklessMarkers = [];
      const reversalMarkers = [];
      const volThreshold = parseInt(volumeFilterInput.value) || 0;
      
      try {
        for (let i = 3; i < haCandles.length - 1; i++) {
          const prev3 = haCandles[i-3];
          const prev2 = haCandles[i-2];
          const prev1 = haCandles[i-1];
          const curr = haCandles[i];
          
          if (curr.volume < volThreshold) continue;
          
          const bodySize = Math.abs(curr.close - curr.open);
          const totalRange = curr.high - curr.low;
          const upperWick = curr.high - Math.max(curr.open, curr.close);
          const lowerWick = Math.min(curr.open, curr.close) - curr.low;
          
          // Doji detection
          if (bodySize < totalRange * 0.15 && totalRange > 0) {
            const dojiColor = curr.close > curr.open ? 'green' : 'red';
            dojiMarkers.push({
              time: curr.time,
              position: 'aboveBar',
              color: dojiColor === 'green' ? '#10b981' : '#ef4444',
              shape: 'circle',
              text: `${timeframe} ${dojiColor.charAt(0).toUpperCase() + dojiColor.slice(1)} Doji`,
              size: 1.5
            });
            
            // Reversal detection at trend extremes
            if (i > 5) {
              const trend = detectTrend(haCandles.slice(0, i), 4);
              if ((trend === 'up' && dojiColor === 'red') || (trend === 'down' && dojiColor === 'green')) {
                reversalMarkers.push({
                  time: curr.time,
                  position: dojiColor === 'green' ? 'belowBar' : 'aboveBar',
                  color: '#f59e0b',
                  shape: dojiColor === 'green' ? 'arrowUp' : 'arrowDown',
                  text: `Potential ${trend === 'up' ? 'Bearish' : 'Bullish'} Reversal`,
                  size: 2
                });
                
                if (enableAlertsToggle.checked) {
                  if (trend === 'up' && dojiColor === 'red') {
                    addAlert('sell', `${currentSymbol} ${timeframe}: Potential Bearish Reversal (Red Doji after uptrend)`, 'pattern-doji');
                  } else if (trend === 'down' && dojiColor === 'green') {
                    addAlert('buy', `${currentSymbol} ${timeframe}: Potential Bullish Reversal (Green Doji after downtrend)`, 'pattern-doji');
                  }
                }
              }
            }
          }
          
          // Wickless detection
          if (totalRange > 0 && (upperWick < totalRange * 0.05 || lowerWick < totalRange * 0.05)) {
            const isUpperWickless = upperWick < totalRange * 0.05;
            const isLowerWickless = lowerWick < totalRange * 0.05;
            
            // Check if first in series
            const prevUpperWick = prev1.high - Math.max(prev1.open, prev1.close);
            const prevLowerWick = Math.min(prev1.open, prev1.close) - prev1.low;
            const prevRange = prev1.high - prev1.low;
            
            if ((isUpperWickless && prevUpperWick >= prevRange * 0.05) || 
                (isLowerWickless && prevLowerWick >= prevRange * 0.05)) {
              
              const wicklessType = isUpperWickless ? 'Upper' : 'Lower';
              wicklessMarkers.push({
                time: curr.time,
                position: isUpperWickless ? 'aboveBar' : 'belowBar',
                color: '#f97316',
                shape: isUpperWickless ? 'arrowDown' : 'arrowUp',
                text: `First ${wicklessType} Wickless`,
                size: 1.8
              });
              
              if (enableAlertsToggle.checked) {
                if (isUpperWickless && curr.close > curr.open) {
                  addAlert('buy', `${currentSymbol} ${timeframe}: Strong Bullish Signal (First Upper Wickless Green Candle)`, 'pattern-wickless');
                } else if (isLowerWickless && curr.close < curr.open) {
                  addAlert('sell', `${currentSymbol} ${timeframe}: Strong Bearish Signal (First Lower Wickless Red Candle)`, 'pattern-wickless');
                }
              }
            }
          }
          
          // Additional reversal patterns
          if (i > 6) {
            const recentTrend = detectTrend(haCandles.slice(i-6, i), 5);
            const currColor = curr.close > curr.open ? 'green' : 'red';
            const prevColor = prev1.close > prev1.open ? 'green' : 'red';
            
            if (recentTrend !== 'neutral' && prevColor !== currColor) {
              const trendStrength = getTrendStrength(haCandles.slice(i-6, i), 5);
              if (trendStrength > 0.6) {
                reversalMarkers.push({
                  time: curr.time,
                  position: currColor === 'green' ? 'belowBar' : 'aboveBar',
                  color: '#ec4899',
                  shape: currColor === 'green' ? 'arrowUp' : 'arrowDown',
                  text: `Trend Reversal Signal`,
                  size: 1.6
                });
                
                if (enableAlertsToggle.checked) {
                  if (currColor === 'green') {
                    addAlert('buy', `${currentSymbol} ${timeframe}: Trend Reversal - Bullish Signal`, 'pattern-reversal');
                  } else {
                    addAlert('sell', `${currentSymbol} ${timeframe}: Trend Reversal - Bearish Signal`, 'pattern-reversal');
                  }
                }
              }
            }
          }
        }
      } catch (error) {
        showError('Pattern detection failed', error.message);
      }
      
      return { dojiMarkers, wicklessMarkers, reversalMarkers };
    }
    
    function detectTrend(candles, lookback) {
      if (candles.length < lookback) return 'neutral';
      
      const slice = candles.slice(-lookback);
      const greens = slice.filter(c => c.close > c.open).length;
      const reds = slice.filter(c => c.close < c.open).length;
      
      if (greens >= lookback * 0.7) return 'up';
      if (reds >= lookback * 0.7) return 'down';
      return 'neutral';
    }
    
    function getTrendStrength(candles, lookback) {
      if (candles.length < lookback) return 0;
      
      const slice = candles.slice(-lookback);
      let bodySum = 0;
      let rangeSum = 0;
      
      for (const candle of slice) {
        bodySum += Math.abs(candle.close - candle.open);
        rangeSum += candle.high - candle.low;
      }
      
      return rangeSum > 0 ? bodySum / rangeSum : 0;
    }
    
    // Marker updates
    function updateMarkers() {
      try {
        const selectedPatterns = Array.from(patternSelect.selectedOptions).map(opt => opt.value);
        
        Object.values(activeCharts).forEach(chartData => {
          const markers = [];
          
          if (selectedPatterns.includes('doji') && chartData.dojiMarkers) {
            markers.push(...chartData.dojiMarkers);
          }
          if (selectedPatterns.includes('wickless') && chartData.wicklessMarkers) {
            markers.push(...chartData.wicklessMarkers);
          }
          if (selectedPatterns.includes('reversal') && chartData.reversalMarkers) {
            markers.push(...chartData.reversalMarkers);
          }
          
          if (chartData.candleSeries) {
            chartData.candleSeries.setMarkers(markers);
          }
          
          // Show/hide zones based on selection
          const showZones = selectedPatterns.includes('zones');
          if (chartData.priceLines) {
            chartData.priceLines.forEach(priceLine => {
              try {
                priceLine.applyOptions({ visible: showZones });
              } catch (e) {
                console.warn('Failed to toggle price line visibility:', e);
              }
            });
          }
        });
      } catch (error) {
        console.warn('Failed to update markers:', error);
      }
    }
    
    // Data fetching with retry logic
    async function fetchChartData(timeframe) {
      const intervalMap = {
        '1m': '1m',
        '5m': '5m',
        '15m': '15m',
        '1h': '1h',
        '4h': '4h',
        '1d': '1d',
        '1w': '1w'
      };
      
      const maxRetryAttempts = 3;
      let attempt = 0;
      
      // Try to get cached data first
      const cachedData = getCachedChartData(currentSymbol, timeframe);
      if (cachedData) {
        updateConnectionStatus(true, 'Using cached data');
        return cachedData;
      }
      
      while (attempt < maxRetryAttempts) {
        try {
          updateConnectionStatus(true, 'Fetching data...');
          connectionStatus.className = 'status-indicator status-loading';
          
          const response = await fetch(
            `https://api.binance.com/api/v3/klines?symbol=${currentSymbol}&interval=${intervalMap[timeframe]}&limit=300`,
            { timeout: 10000 }
          );
          
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const data = await response.json();
          
          if (!Array.isArray(data) || data.length === 0) {
            throw new Error('Invalid data received from API');
          }
          
          const formattedData = data.map(d => ({
            time: Math.floor(d[0] / 1000),
            open: parseFloat(d[1]),
            high: parseFloat(d[2]),
            low: parseFloat(d[3]),
            close: parseFloat(d[4]),
            volume: parseFloat(d[5])
          }));
          
          // Store the data for future use
          storeChartData(currentSymbol, timeframe, formattedData);
          
          updateConnectionStatus(true, 'Connected');
          updateTime.textContent = new Date().toLocaleTimeString();
          
          return formattedData;
          
        } catch (error) {
          attempt++;
          console.error(`Fetch attempt ${attempt} failed:`, error);
          
          if (attempt >= maxRetryAttempts) {
            updateConnectionStatus(false, `Failed to fetch data: ${error.message}`);
            showError(
              'Failed to fetch market data',
              `Unable to connect to Binance API after ${maxRetryAttempts} attempts. Please check your internet connection.`
            );
            return [];
          }
          
          // Wait before retry (exponential backoff)
          await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, attempt - 1)));
        }
      }
    }
    
    // Chart loading with fixed price line updates
    async function loadChart(timeframe) {
      try {
        loadingIndicator.style.display = 'block';
        
        // Check if we already have a chart for this timeframe
        if (!activeCharts[timeframe]) {
          // Create new chart if it doesn't exist
          const chartElements = createChartElement(timeframe);
          activeCharts[timeframe] = { 
            ...chartElements,
            dojiMarkers: [], 
            wicklessMarkers: [], 
            reversalMarkers: [], 
            haCandles: [],
            priceLines: []
          };
        }
        
        const chartData = activeCharts[timeframe];
        const candles = await fetchChartData(timeframe);
        
        if (candles.length === 0) {
          loadingIndicator.style.display = 'none';
          return;
        }
        
        const haCandles = convertToHeikinAshi(candles);
        chartData.haCandles = haCandles;
        
        // Update chart data
        chartData.candleSeries.setData(haCandles);
        
        // Update chart title with current price
        const currentPrice = haCandles[haCandles.length - 1].close;
        const titleElement = chartData.wrapper.querySelector('.absolute');
        if (titleElement) {
          titleElement.innerHTML = `
            <i class="fab fa-bitcoin mr-2"></i>
            ${currentSymbol} ${timeframe} Heikin Ashi - $${currentPrice.toFixed(2)}
          `;
        }
        
        // Draw support/resistance zones with proper price line management
        drawZones(haCandles, chartData);
        
        // Detect patterns
        const patterns = detectHeikinAshiPatterns(haCandles, timeframe);
        chartData.dojiMarkers = patterns.dojiMarkers;
        chartData.wicklessMarkers = patterns.wicklessMarkers;
        chartData.reversalMarkers = patterns.reversalMarkers;
        
        updateMarkers();
        
        // Add tooltip functionality if not already added
        if (!chartData._hasTooltip) {
          chartData.chart.subscribeCrosshairMove(param => {
            if (!param.point || !param.time) {
              tooltipEl.style.display = 'none';
              return;
            }
            
            const allMarkers = [
              ...(chartData.dojiMarkers || []),
              ...(chartData.wicklessMarkers || []),
              ...(chartData.reversalMarkers || [])
            ];
            
            const marker = allMarkers.find(m => m.time === param.time);
            if (marker) {
              tooltipEl.innerHTML = `
                <div class="text-xs font-medium">${marker.text}</div>
                <div class="text-xs text-secondary mt-1">
                  ${new Date(param.time * 1000).toLocaleString()}
                </div>
              `;
              tooltipEl.style.left = `${param.point.x + 15}px`;
              tooltipEl.style.top = `${param.point.y - 10}px`;
              tooltipEl.style.display = 'block';
            } else {
              tooltipEl.style.display = 'none';
            }
          });
          chartData._hasTooltip = true;
        }
        
        loadingIndicator.style.display = 'none';
        
      } catch (error) {
        loadingIndicator.style.display = 'none';
        showError('Failed to load chart', error.message);
      }
    }
    
    function loadCharts(timeframe) {
      // Clean up old charts (except the current one)
      Object.keys(activeCharts).forEach(tf => {
        if (tf !== timeframe) {
          const chartData = activeCharts[tf];
          if (chartData.resizeObserver) {
            chartData.resizeObserver.disconnect();
          }
          if (chartData.wrapper) {
            chartData.wrapper.remove();
          }
          delete activeCharts[tf];
        }
      });
      
      loadChart(timeframe);
      startRefreshTimer();
    }
    
    // Event listeners
    patternSelect.addEventListener('change', updateMarkers);
    enableAlertsToggle.addEventListener('change', () => {
      if (enableAlertsToggle.checked) {
        showSuccess('Alerts enabled');
      } else {
        showSuccess('Alerts disabled');
      }
    });
    
    volumeFilterInput.addEventListener('input', () => {
      volumeDisplay.textContent = volumeFilterInput.value;
      updateMarkers();
    });
    
    // Initialize application
    function initialize() {
      try {
        initializeTheme();
        renderAlerts();
        loadCharts(currentTimeframe);
        updateConnectionStatus(false, 'Initializing...');
        
        // Initial load
        setTimeout(() => {
          if (isOnline) {
            showSuccess('Application initialized successfully');
          }
        }, 2000);
        
      } catch (error) {
        showError('Failed to initialize application', error.message);
      }
    }
    
    // Start the application
    initialize();
    
    // Handle page visibility changes
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        if (refreshInterval) clearInterval(refreshInterval);
      } else {
        startRefreshTimer();
        if (Date.now() - lastRefreshTime > 60000) { // Refresh if more than 1 minute old
          refreshCharts();
        }
      }
    });
    
    // Handle window resize
    window.addEventListener('resize', () => {
      Object.values(activeCharts).forEach(chartData => {
        if (chartData.chart) {
          chartData.chart.applyOptions({
            width: chartData.chart.chartElement().clientWidth
          });
        }
      });
    });
    
    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      Object.values(activeCharts).forEach(chartData => {
        if (chartData.resizeObserver) {
          chartData.resizeObserver.disconnect();
        }
        // Clean up price lines
        if (chartData.priceLines) {
          chartData.priceLines.forEach(pl => {
            try {
              chartData.candleSeries.removePriceLine(pl);
            } catch (e) {
              console.warn('Failed to remove price line on cleanup:', e);
            }
          });
        }
      });
    });
  </script>
</body>
</html>
